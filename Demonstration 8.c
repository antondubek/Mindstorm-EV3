#pragma config(Sensor, S2,     ultrasonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     colour,         sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Motor,  motorA,          mediumMotor,   tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*void scanOne () //Initial Scan Function
{
int closest = 300; //Sets the closest distance as 300cm
int i;

for (i=0; i<=15;i++)  //Number of scans taken
{
sleep(250); //Sleep function put in to try and stop jittering in scan movement (250 = quite slow)

//If statement takes the closest reading of the ultrasonic sensor and resets the gyro so robot knows how far it has moved from that reading//
if(getUSDistance(ultrasonic) < closest)
{
closest = getUSDistance(ultrasonic);
resetGyro (gyro);
}

turnRight(20, degrees, 30); //Scan turns right 20 'wheel degrees' at a speed of 30



}
}

void scanTwo() //Second smaller and faster scan
{
int closest = 300;
int i;

for(i=0; i<=5; i++) //5 Scans taken
{
sleep(100); //Small pause put in to stop jittering however keeps scan relatively quick

if(getUSDistance(ultrasonic) < closest)
{
closest = getUSDistance(ultrasonic);
resetGyro(gyro);
}

turnRight(15, degrees, 20); //Scan turns right 15 'wheel degrees' at a speed of 20
}
}



task main()
{
while (true)
{
turnLeft(150, degrees, 50); //Turns the robot initially left c.90 degrees on the spot
scanOne(); //Robot then scans turning right

//Converts the gyro reading into 'wheel degrees' needed in order to get back. Theoretical is 2.38//
int firstAngle = getGyroDegrees(gyro);
int gyroConversion = getGyroDegrees(gyro) * 1.78;

//Turns the robot back left to the closest reading it made
turnLeft(gyroConversion, degrees, 30);
sleep(250); //Small sleep added in before moving to get set

//Moves the robot to within 10cm of the object at 50 speed. 0.06 rotations approx 1cm taking real world factors into account. Theoretical value is at 0.046. //
int goForwardDistance = (getUSDistance(ultrasonic) - 10) * 0.060;
forward(goForwardDistance, rotations, 50);

turnLeft(40, degrees, 50); //Turns left 40 'wheel degrees' before running second scan
sleep(250); //Small wait so not as rushed trying to turn left and then right
scanTwo(); //Runs smaller faster second scan to check it is in correct postiition

//Adjusts to the new readings from the smaller scan
gyroConversion = getGyroDegrees(gyro) * 1.8;
turnLeft(gyroConversion, degrees, 30);

displayVariableValues(line2, getUSDistance(ultrasonic));
displaySensorValues(line4, ultrasonic);
sleep(1000);

forward(0.75, rotations, 10);

moveMotor(mediumMotor, 3.5, rotations, -50);

sleep(1000);

while(getColorHue(colour) < 300)
{
setMultipleMotors(-10, leftMotor, rightMotor);
}

setMultipleMotors(0, leftMotor, rightMotor);
sleep(500);

gyroConversion = (180 - firstAngle) * 1.75;
turnLeft(gyroConversion, degrees, 10);
sleep(250);
turnLeft(180, degrees, 10);
sleep(250);
forward(1, rotations, 10);
sleep(250);
moveMotor(mediumMotor, 3.5, rotations, 50);
sleep(1000);
backward(1, rotations, 10);
sleep(1000);
turnRight(315, degrees, 10);
sleep(1000);
}

}
*/

void initialScan() //Initial Scan Function
{
	int closest = 300; //Sets the closest distance as 300cm
	int i;

	for (i=0; i<=15;i++)  //Number of scans taken
	{
		sleep(100); //Sleep function put in to try and stop jittering in scan movement (250 = quite slow)

		//If statement takes the closest reading of the ultrasonic sensor and resets the gyro so robot knows how far it has moved from that reading//
		if(getUSDistance(ultrasonic) < closest)
		{
			closest = getUSDistance(ultrasonic);
			resetGyro (gyro);
		}

		turnRight(22, degrees, 15); //Scan turns right 20 'wheel degrees' at a speed of 30

		/*displaySensorValues(4, ultrasonic);
		sleep(1000);*/
	}
}

float gyroConversion()
{
	float conversion = getGyroDegrees(gyro) * 1.75;
	return conversion;
}

float gyroConversionTwo()
{
	float conversion = getGyroDegrees(gyro) * 1.833;
	return conversion;
}

float goForwardDistance()
{
	float distance = (getUSDistance(ultrasonic) - 10) * 0.046;
	return distance;
}

void secondScan() //Second smaller and faster scan
{
	int closest = 300;
	int i;

	for(i=0; i<=5; i++) //5 Scans taken
	{
		sleep(100); //Small pause put in to stop jittering however keeps scan relatively quick

		if(getUSDistance(ultrasonic) < closest)
		{
			closest = getUSDistance(ultrasonic);
			resetGyro(gyro);
		}

		turnRight(18.3, degrees, 20); //Scan turns right 10 'degrees' at a speed of 20
	}
}

void depositTurn(int i)
{
	if(i == 0)
	{
		turnLeft(220, degrees, 50); //120
	}

	if(i == 1)
	{
		turnLeft(165, degrees, 50); //90
	}

	if(i == 2)
	{
		turnLeft(110, degrees, 50); //60
	}
}

void depositTurnBack(int i)
{
	if(i == 0)
	{
		turnRight(220, degrees, 50); //120
	}

	if(i == 1)
	{
		turnRight(165, degrees, 50); //90
	}

	if(i == 2)
	{
		turnRight(110, degrees, 50); // 60
	}
}

task main()
{

	for(int number = 0; number < 3; number++)
	{
		//Turn initially left 90 degrees
		//turnLeft(150, degrees, 50);

		//Calls initial scan
		initialScan();

		//Saves the initial Gyro Number
		float initialGyroNumber = getGyroDegrees(gyro);

		//Turn back the gyro conversion
		turnLeft(gyroConversion(), degrees, 30);
		sleep(250);

		//GoForward to within 10cm
		forward(goForwardDistance(), rotations, 30);

		//Turn Left for second scan
		turnLeft(45.83, degrees, 50);

		//Calls second Scan
		secondScan();

		//Saves Second Gyro Number
		float secondGyroNumber = getGyroDegrees(gyro);

		//Turn back gyro conversion 2
		turnLeft(gyroConversionTwo(),degrees, 30);

		//Moves into object
		forward(270, degrees, 20);
		sleep(100);

		//Closes gripper
		moveMotor(mediumMotor, 5.5, rotations, -50);
		sleep(100);

		//Moves back from object
		backward(270, degrees, 20);
		sleep(100);

		//Turns so back faces line
		float SecondgyroConversion = (25 - secondGyroNumber) * 1.90;

		if(SecondgyroConversion < 0)
		{
			float SecondGyroConversionRight = SecondgyroConversion - SecondgyroConversion - SecondgyroConversion;
			turnRight(SecondGyroConversionRight, degrees, 20);
		}

		else
		{
			turnLeft(SecondgyroConversion, degrees, 20);
		}

		//Move backwards Until Red Detected
		while(getColorHue(colour) < 320)
		{
			setMultipleMotors(-20, leftMotor, rightMotor);
		}

		//Stop when red detected
		setMultipleMotors(0, leftMotor, rightMotor);

		//Turn back to parallel with line
		float InitialgyroConversion = (200 - initialGyroNumber) * 1.833;
		turnLeft(InitialgyroConversion, degrees, 20);
		sleep(250);

		//Turns round 3 different directions
		int f = 0;
		depositTurn(f);
		f++;

		//Forward before dumping
		forward(1, rotations, 20);

		//Open the gripper
		moveMotor(mediumMotor, 5.5, rotations, 50);
		sleep(100);

		//Reverse back to line
		backward(1, rotations, 20);

		//turn back round to parallel with line
		int t = 0;
		depositTurnBack(t);
		t++;
	}

	turnRight(220, degrees, 50); //120
	forward(1, rotations, 30);
	turnRight(5, rotations, 100);
}
